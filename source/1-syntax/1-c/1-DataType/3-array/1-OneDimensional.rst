一维数组
==========

接下来我们将从以下几个方面来学习一维数组

- \ `数组定义 <#defineone>`_\ 
- \ `数组初始化 <#initone>`_\ 
- \ `数组访问 <#accessone>`_\ 
- \ `数组应用 <#applyone>`_\   


.. _defineOne: 

0x00 数组定义
~~~~~~~~~~~~~~~

一维数组声明定义的格式是：\ ``type ArrayName [ArraySize];``\ 

- \ **type**\ ：数组元素的数据类型
- \ **ArrayName**\ ：数组的数组名
- \ **ArraySize**\ ：数组元素的数量

例如：\ ``int a[10];``\ 定义了一个名为\ **a**\ 的数组，该数组有10个成员 每个成员都是int类型

- 该定义开辟了\ ``sizeof(int)*10=40``\ 字节的内存空间，依次连续存放\ **a[0]~a[9]**\ 10个元素
- 数组名\ ``a``\ 是一个常量[不能当做变量被赋值]，它代表数组首元素的地址
- 此时该数组并没有被初始化，每个元素的值是随机的

定义数组时，ArraySize可以是变量，其定义方法可以是

.. code-block:: c

	//方法一：c99之后的编译器才支持
	int i = 10;
	int a[i];

	//方法二：标准c写法
	#define NUM 10
	int a[NUM];

\ **注意**\ ：\ ``char a[10];``\ 

- \ ``a``\ 表示数组首元素的地址，即\ ``a[0]``\ 元素的地址，\ ``a+1``\ 表示\ ``a[1]``\ 的地址
- \ ``&a``\ 表示整个数组的首地址，\ ``&a+1``\ 表示跳过了整个数组

.. _initOne: 

0x01 数组初始化
~~~~~~~~~~~~~~~~~~

当定义一个数组时只是分配了相应的内存空间，内存空间存储的依然是之前的随机值，此时需要通过初始化存放我们想要存储的数据；数组初始化的方式有：

- \ ``int a[4] = {1,2,3,4};``\ ：a[0]~a[3]的值分别初始化为1,2,3,4；每个元素都占用4字节空间
- \ ``int a[4] = {1,3};``\ ：a[0]初始化为1，a[1]初始化为3，a[2]~a[3]初始为0；每个元素都占用4字节空间
- \ ``int a[] = {1,2,3};``\ ：数组a只有3个元素，分别初始化为1,2,3；每个元素都占用4字节空间
- \ ``int a[4] = {0};``\ ：a[0]~a[3]都初始化为0；每个元素都占用4字节空间
- \ ``char a[4] = {0}``\ ：a[0]~a[3]都初始好为0；每个元素都占用1字节空间
- \ ``char a[6] = "hello"``\ ：a[0]~a[5]分别初始化为\ **'h'/'e'/'l'/'l'/'o'/'\0'**\ ；每个元素占用1个字节。注意：数组元素的个数一定要大于字符串常量的长度，因为字符串是以'\0'结尾，"hello"实际是以\ **'h'/'e'/'l'/'l'/'o'/'\0'**\ 存放的
- \ ``char a[10] = "hello"``\ ：a[0]~a[5]分别初始化为\ **'h'/'e'/'l'/'l'/'o'/'\0'**\ ，剩余元素都初始为0；每个元素都占用1个字节空间


.. _accessOne: 

0x02 数组访问
~~~~~~~~~~~~~~~~

数组是通过索引下标的方式来访问元素的，以下demo代码就是访问数组每个元素然后打印输出

.. code-block:: c

	#include <stdio.h>
	int main(){
		int i;
		int a[] = {1,2,3,4,5};
		for(i=0; i < sizeof(a)/sizeof(a[0]); i++) {
			printf("%d\n",a[i]);
		}

		return 0;
	}


上述demo代码中：

 - \ ``sizeof(a)``\ 表示数组a在内存中占用大小
 - \ ``sizeof(a[0])``\ 表示数组a的首元素在内存中占用大小[即每个元素在内存中占用大小]
 - \ ``sizeof(a)/sizeof(a[0])``\ 表示数组元素的个数

.. _applyOne: 

0x03 数组应用
~~~~~~~~~~~~~~~

冒泡排序
++++++++++
算法思路

- 第一次遍历整个数组10个元素，通过相邻值比较将最大值放到最右边
- 第二次遍历剩下的9个元素，通过相邻值比较将最大值放到最右边
- 依次循环遍历，直到遍历最后1个元素

代码实现如下：

.. code-block:: c

	#include <stdio.h>
	int main(){
		int i, j;
		int a[] = {34,5,124,624,3,65,};
		int count = sizeof(a)/sizeof(a[0]);
		for(i = 0;i < count;i++){
			for(j = 1;j < count-i;j++){
				if(a[j] > a[j-1]){
					int tmp = a[j-1];
					a[j-1] =a[j];
					a[j] = tmp;
				}
			}
		}

		for(i=0; i < count; i++) {
			printf("%d\n",a[i]);
		}

		return 0;
	}

